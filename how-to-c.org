* How to C
* How to C

This is a development environment where only the paranoid can survive.

-- John Regehr [1]

* Scope

I assume you know the basics of C.

This talk is not exhaustive because there's tons of little fun things that are
hard to fit in a talk. 

Also, if you use them, you're literally Satan and are either a cool person or an
extreme violator of the psychopath rule.

* Why does C continue to exist

Pointers are real. They’re what the hardware understands. Somebody has to deal
with them. You can’t just place a LISP book on top of an x86 chip and hope that
the hardware learns about lambda calculus by osmosis. Denying the existence of
pointers is like living in ancient Greece and denying the existence of Krackens
and then being confused about why none of your ships ever make it to Morocco, or
Ur-Morocco, or whatever Morocco was called back then. Pointers are like Krackens
— real, living things that must be dealt with so that polite society can exist.

-- James Mickens [2]

* When to use C

System Programming within a SMALL team where cohesion can be maintained.

* When not to use C

C is difficult to manage in the interface between components.
It has no tools to enforce or detect cohesion.

The bigger the project/team the more components you have.
The more components you have the harder it is to maintain cohesion.

Also, if you're not doing systems programing, use python or something...

* Standards - K&R
Ye olde C from a bygone era...

#+BEGIN_SRC c
void blah(void)
    int a;
{
    ...
}
#+END_SRC

K&R still has its place in history but we've come a long way since...

* Standards - C99

This is our base that's supported mostly everywhere.

... unless you do emdbed in which case... good luck?

* Standards - C11

Adds a memory model!
Adds a few quality of life features.

This is what I target.

* Undefined Behaviour - Definition

The gap between what you can do and what you're allowed to do.

* Undefined Behaviour - Simple Example

#+BEGIN_SRC c
int a = INT_MAX + 1;
#+END_SRC

* Undefined Behaviour - What can go wrong?

Usually manifests during optimization.

Compiler assumes that something is not possible and makes optimization decisions
as a result.

* Undefined Behaviour - Linux Example

Famous Linux example...

#+BEGIN_SRC c
void blah(int *ptr)
{
   int x = *ptr + 5;        // accessing ptr would be undefined behaviour if NULL
   if (ptr == NULL) return; // therefore this `if` is a noop and can be removed.
   bleh(x);                 // calling blah(NULL) is now no longer safe. Whee!
}
#+END_SRC

Absolutely horrible code. Never write shit like this.

Newer versions of gcc and clang will warn on this.

Never assume consistent handling across compiler versions.

What works now, may not work in a year or when targetting a different arch.

* Undefined Behaviour - Why though?

Why not have the compiler detect it?

Many classes of undefined behaviours can only be detected at runtime.

Runtime checks are expensive.

Many have tried to specify safe C.

C is used in too many use cases where a safe subset that satisfy everyone simply
doesn't exist.

* Undefined Behaviour - Alright, I'm sad now...

Where does that leave us?

Learn your undefined behaviours and be very paranoid.

* Undefined Beahviour vs Implementation Defined Behaviour ?

Implementation defined means the compiler chooses one option and stays
consistent with its decision.

Different compilers or architecture may choose differently.

Much more rare and usually has to do with data or memory layout.

Example: struct padding

* Ints

One of the worst part about C...

... that C++ decided to inherit wholesale...

* Ints - Simple Question?

#+BEGIN_SRC c
sizeof(int)
#+END_SRC

What does that return?

* Ints - Complex Answer...

IT DEPENDS! Oh what joy!

int is defined as being *AT LEAST* 16 bits [3]

It will generally be 32 bit on most systems.

* Ints - Simple Question ...?

How many int types are there?

* Ints - Nevermind, I give up...

[signed|unsigned] [long] [char|short|int|long] [int]

... or kinda... who cares... it's a mess...

short
short int
signed short
signed short int

are all equivalent to

short int

* Ints - Please save me...

Screw all of that...

#+BEGIN_SRC c
#include <stddef.h>
#include <stdint.h>
#+END_SRC

These headers are your friends.

* Ints - For when you don't know what you want

#+BEGIN_SRC c
#include <stddef.h>

size_t a;
ssize_t b;
#+END_SRC

Defined in standard to be big enough to index any element in an array.

Another of saying that it's big enough to hold any memory address.

This is my default and what you want 90% of the time.

* Ints - For when you know what you want

#+BEGIN_SRC c
#include <stdint.h>

uint8_t a = UINT8_MAX;
int16_fast16_t b = INT16_FAST_MAX;
#+END_SRC

Allows you to better declare your exact requirements from the int and have
explicit bounds.

* Ints - char can't be complex... right?

char is just a int type.

This means that by default it's signed.

Yes... you read that right, chars are signed by default.

* Ints - But I want to reference raw bytes...

To express the notion of a byte you can do:

#+BEGIN_SRC c
unsigned char x;
#+END_SRC

But semantically that's insane...

I recommend:

#+BEGIN_SRC c
uint8_t x;
#+END_SRC

They're equivalent but the later has a stronger semantic meaning.

Questions about why not void points are differed to later.

* Ints - Who knew negative numbers could be so evil

Signed ints are prone to undefined behaviours...

#+BEGIN_SRC c
int a = INT_MAX + 1;
int b = INT_MIN - 1;
int8_t a = ((int8_t) 1) << 7; // shift into sign bit
#+END_SRC

Equivalent expression for unsigned are all well defined.

As a result I tend to prefer unsigned unless I need signed expressions.

* Ints - Just in case you though you were safe...

#+BEGIN_SRC c
uint8_t a = ((uint8_t) 1) << 8;
#+END_SRC

Shifting past the length is undefined so check yours bounds.

* Ints - Surely literals are the last bastion of safety?

Literals are always ints!
This means they're signed!

#+BEGIN_SRC c
1 << 48;
#+END_SRC

This is technically undefined behariour but most compiler will catch it and tell
you to fix your shit...

* Ints - All I wanted was a number...

There are specifiers you can use to change the type of a literal:

#+BEGIN_SRC c
1U;   // unsgined
1L;   // long
1UL;  // unsigned long
1ULL; // unsigned long long (aka. 64 bits)
#+END_SRC

As a fun exercise, replace the 1 by 0xF.

* Ints - Please get me out of here...

ints in C are a minefield.

This is your basic primitive type and they're not even safe!

Well it only gets worst because of...

* Strings - Here we go again

The second worst part of C

The source of SO many security problems

* Strings - Basics

#+BEGIN_SRC c
const char *a = "bob";
#+END_SRC

Equivalent (or close enough):

#+BEGIN_SRC c
const char a[] = {'b', 'o', 'b', 0};
#+END_SRC

That 0 at the end is the source of so much woe and misery in the world.

* Strings - str, the dysfunctional family 

All these functions assumes that you have a trailing 0.

#+BEGIN_SRC c
strlen(str);
strdup(str);        // don't forget to call free...
strcmp(s1, s2);
strcpy(dst, src);
strcat(dst, src);
strtok(str, delim); // uses global state ?!
#+END_SRC

If it's missing? It'll just keep reading memory until it finds one. Or else...

* Strings - Security!

What's that? Your string is on the stack? 

It would be a shame if someone were to write a very specific number in your
return address for your function...


Oh no... Is your string on the heap?

It would be a shame if someone wrote random bytes to completely unrelated data
structures that you'll only find out way after the str function finishes...

* Strings - strn, the slightly ok family

I **ALWAYS** default to the strn family

#+BEGIN_SRC c
strnlen(str, len);
strndup(str, len);        // don't forget to call free...
strncmp(s1, s2, len);
strncpy(dst, src, len);
strncat(dst, src, len);
#+END_SRC

strn variants ensure that no more then len bytes will be read.

Get in the habit of using them even if obviously correct otherwise.

Don't be that guy...

* Strings - ALWAYS! Except...

Warning: If there is no null byte among the first n bytes of src, the string
placed in dest will not be null-terminated.

If the length of src is less than n, strncpy() writes additional null bytes to
dest to ensure that a total of n bytes are written.

-- man strncpy

* Strings - WHY?!

WHY?!

* Strings - BSD? Care to chime in?

Third time's the charm...?

#+BEGIN_SRC c
strlcpy(dst, src, len);
#+END_SRC

You need to compile with -lbsd and make you have libbsd installed.

* Strings - Hey! What about strtok?

urg... you had to remember...

#+BEGIN_SRC c
strtok_r(str, delim, saveptr);
#+END_SRC

_r means that the function is reentrant.

You know you fucked up when you have to specify that for a string function.

saveptr is the state the be used in between calls.

* Strings - Paranoia is not paranoia when it's justified

The standard library for C is insane and out to get you.

Period. No questions. That's just the reality.

NEVER EVER use a function from the standard lib without having read its manpage
first.

I still regurlarly recheck man pages for basic functions like strnlen.

Just to be sure...

* Arrays - Let's play with bytes

#+END_SRC

* Reference

[1]: https://blog.regehr.org/archives/1393
[2]: https://www.usenix.org/system/files/1311_05-08_mickens.pdf
[3]: https://en.cppreference.com/w/cpp/language/types

